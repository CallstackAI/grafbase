use super::types::{Record, Row, Sql};
use crate::constant::*;
use crate::graph_transaction::{
    DeleteAllRelationsInternalInput, DeleteMultipleRelationsInternalInput, DeleteNodeInternalInput,
    DeleteRelationInternalInput, ExecuteChangesOnDatabase, InsertNodeInternalInput, InsertRelationInternalInput,
    InternalChanges, InternalNodeChanges, InternalRelationChanges, ToTransactionError, ToTransactionFuture,
    UpdateNodeInternalInput, UpdateRelation, UpdateRelationInternalInput,
};
use crate::{DynamoDBBatchersData, DynamoDBContext};
use chrono::{SecondsFormat, Utc};
use dynomite::{Attribute, AttributeValue};
use itertools::Itertools;
use std::collections::HashMap;

impl ExecuteChangesOnDatabase for InsertNodeInternalInput {
    fn to_transaction<'a>(
        self,
        _batchers: &'a DynamoDBBatchersData,
        _ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        Box::pin(async {
            let InsertNodeInternalInput {
                id,
                user_defined_item,
                ty,
            } = self;

            let id = format!("{}#{}", ty, id);
            let utc_now = Utc::now();

            let now_attr = utc_now.to_string().into_attr();
            let ty_attr = ty.clone().into_attr();
            let autogenerated_id_attr = id.clone().into_attr();

            let mut document = user_defined_item;

            document.insert(PK.to_string(), autogenerated_id_attr.clone());
            document.insert(SK.to_string(), autogenerated_id_attr.clone());
            document.insert(TYPE.to_string(), ty_attr.clone());
            document.insert(CREATED_AT.to_string(), now_attr.clone());
            document.insert(UPDATED_AT.to_string(), now_attr);
            document.insert(TYPE_INDEX_PK.to_string(), ty_attr);
            document.insert(TYPE_INDEX_SK.to_string(), autogenerated_id_attr.clone());
            document.insert(INVERTED_INDEX_PK.to_string(), autogenerated_id_attr.clone());
            document.insert(INVERTED_INDEX_SK.to_string(), autogenerated_id_attr);

            let record = Record {
                pk,
                sk,
                entity_type: ty.clone(),
                created_at: utc_now,
                updated_at: utc_now,
                relation_names: Default::default(),
                gsi1pk: ty,
                gsi1sk: id.clone(),
                gsi2pk: id.clone(),
                gsi2sk: id,
                document,
            };

            let row = Row::from_record(record);

            Ok((Sql::Insert(&row).into(), row.values))
        })
    }
}

impl ExecuteChangesOnDatabase for UpdateNodeInternalInput {
    fn to_transaction<'a>(
        self,
        _batchers: &'a DynamoDBBatchersData,
        _ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        Box::pin(async {
            let UpdateNodeInternalInput { user_defined_item, .. } = self;

            let now = Utc::now().to_rfc3339_opts(SecondsFormat::Millis, true);
            let now_attr = now.clone().into_attr();

            let mut document = user_defined_item;

            document.insert(UPDATED_AT.to_string(), now_attr);

            let updated_at = now;
            let document = serde_json::to_string(&document).expect("must serialize");

            Ok((Sql::Update.into(), vec![document, updated_at, pk, sk]))
        })
    }
}
impl ExecuteChangesOnDatabase for DeleteNodeInternalInput {
    fn to_transaction<'a>(
        self,
        _batchers: &'a DynamoDBBatchersData,
        _ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        Box::pin(async { Ok((Sql::DeleteByIds.into(), vec![pk, sk])) })
    }
}

impl ExecuteChangesOnDatabase for InternalNodeChanges {
    fn to_transaction<'a>(
        self,
        batchers: &'a DynamoDBBatchersData,
        ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        match self {
            Self::Insert(input) => input.to_transaction(batchers, ctx, pk, sk),
            Self::Delete(input) => input.to_transaction(batchers, ctx, pk, sk),
            Self::Update(input) => input.to_transaction(batchers, ctx, pk, sk),
        }
    }
}

impl ExecuteChangesOnDatabase for InsertRelationInternalInput {
    fn to_transaction<'a>(
        self,
        _batchers: &'a DynamoDBBatchersData,
        _ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        Box::pin(async move {
            let InsertRelationInternalInput {
                fields,
                relation_names,
                from_ty,
                to_ty,
                ..
            } = self;

            let utc_now = Utc::now();

            let mut document = fields;

            let now_attr = utc_now.to_string().into_attr();
            let gsi1pk_attr = from_ty.clone().into_attr();
            let ty_attr = to_ty.clone().into_attr();

            document.insert(PK.to_string(), pk.clone().into_attr());
            document.insert(SK.to_string(), sk.clone().into_attr());
            document.insert(TYPE.to_string(), ty_attr);
            document.insert(CREATED_AT.to_string(), now_attr.clone());
            document.insert(UPDATED_AT.to_string(), now_attr);
            document.insert(TYPE_INDEX_PK.to_string(), gsi1pk_attr);
            document.insert(TYPE_INDEX_SK.to_string(), pk.clone().into_attr());
            document.insert(INVERTED_INDEX_PK.to_string(), sk.clone().into_attr());
            document.insert(INVERTED_INDEX_SK.to_string(), pk.clone().into_attr());
            document.insert(
                RELATION_NAMES.to_string(),
                AttributeValue {
                    ss: Some(relation_names.clone()),
                    ..Default::default()
                },
            );

            let record = Record {
                pk: pk.clone(),
                sk: sk.clone(),
                entity_type: to_ty,
                created_at: utc_now,
                updated_at: utc_now,
                gsi1pk: from_ty,
                gsi1sk: pk.clone(),
                gsi2pk: sk.clone(),
                gsi2sk: pk.clone(),
                relation_names: relation_names.clone(),
                document,
            };

            let row = Row::from_record(record);

            Ok((
                Sql::InsertRelation(&row, relation_names.len()).into(),
                vec![vec![pk, sk], relation_names, row.values].concat(),
            ))
        })
    }
}

impl ExecuteChangesOnDatabase for DeleteAllRelationsInternalInput {
    fn to_transaction<'a>(
        self,
        _batchers: &'a DynamoDBBatchersData,
        _ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        Box::pin(async { Ok((Sql::DeleteByIds.into(), vec![pk, sk])) })
    }
}

impl ExecuteChangesOnDatabase for DeleteMultipleRelationsInternalInput {
    fn to_transaction<'a>(
        self,
        _batchers: &'a DynamoDBBatchersData,
        _ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        Box::pin(async {
            let DeleteMultipleRelationsInternalInput { relation_names, .. } = self;

            let now = Utc::now().to_rfc3339_opts(SecondsFormat::Millis, true);
            let now_attr = now.clone().into_attr();

            let mut document = HashMap::<String, AttributeValue>::new();

            document.insert(UPDATED_AT.to_string(), now_attr);

            let updated_at = now;
            let document = serde_json::to_string(&document).expect("must serialize");

            Ok((
                Sql::DeleteRelations(relation_names.len()).into(),
                vec![
                    vec![pk.clone(), sk.clone()],
                    relation_names,
                    vec![document, updated_at, pk, sk],
                ]
                .concat(),
            ))
        })
    }
}

impl ExecuteChangesOnDatabase for DeleteRelationInternalInput {
    fn to_transaction<'a>(
        self,
        batchers: &'a DynamoDBBatchersData,
        ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        match self {
            Self::All(a) => a.to_transaction(batchers, ctx, pk, sk),
            Self::Multiple(a) => a.to_transaction(batchers, ctx, pk, sk),
        }
    }
}

impl ExecuteChangesOnDatabase for UpdateRelationInternalInput {
    fn to_transaction<'a>(
        self,
        _batchers: &'a DynamoDBBatchersData,
        _ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        Box::pin(async {
            let UpdateRelationInternalInput {
                user_defined_item,
                relation_names,
                ..
            } = self;

            let (removed, added): (Vec<String>, Vec<String>) =
                relation_names.into_iter().partition_map(|relation| match relation {
                    UpdateRelation::Add(a) => itertools::Either::Right(a),
                    UpdateRelation::Remove(a) => itertools::Either::Left(a),
                });

            let now = Utc::now().to_rfc3339_opts(SecondsFormat::Millis, true);
            let now_attr = now.clone().into_attr();

            let mut document = user_defined_item;

            document.insert(UPDATED_AT.to_string(), now_attr);

            let updated_at = now;
            let document = serde_json::to_string(&document).expect("must serialize");

            Ok((
                Sql::UpdateWithRelations(removed.len(), added.len()).into(),
                vec![
                    vec![pk.clone(), sk.clone()],
                    removed,
                    added,
                    vec![document, updated_at, pk, sk],
                ]
                .concat(),
            ))
        })
    }
}

impl ExecuteChangesOnDatabase for InternalRelationChanges {
    fn to_transaction<'a>(
        self,
        batchers: &'a DynamoDBBatchersData,
        ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        match self {
            Self::Insert(input) => input.to_transaction(batchers, ctx, pk, sk),
            Self::Delete(input) => input.to_transaction(batchers, ctx, pk, sk),
            Self::Update(input) => input.to_transaction(batchers, ctx, pk, sk),
        }
    }
}

impl ExecuteChangesOnDatabase for Vec<InternalChanges> {
    fn to_transaction<'a>(
        self,
        batchers: &'a DynamoDBBatchersData,
        ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        let mut list = self.into_iter();
        let first = list.next().map(|first| list.try_fold(first, |acc, cur| acc.with(cur)));

        let first = match first {
            Some(Ok(first)) => first,
            _ => return Box::pin(async { Err(ToTransactionError::Unknown) }),
        };

        first.to_transaction(batchers, ctx, pk, sk)
    }
}

impl ExecuteChangesOnDatabase for InternalChanges {
    fn to_transaction<'a>(
        self,
        batchers: &'a DynamoDBBatchersData,
        ctx: &'a DynamoDBContext,
        pk: String,
        sk: String,
    ) -> ToTransactionFuture<'a> {
        match self {
            Self::Node(input) => input.to_transaction(batchers, ctx, pk, sk),
            Self::Relation(input) => input.to_transaction(batchers, ctx, pk, sk),
            Self::NodeConstraints(_) => todo!(),
        }
    }
}
